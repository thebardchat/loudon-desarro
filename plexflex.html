<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PLEX FLEX™ — Telescopic Floor-Lift Beams</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=Barlow+Condensed:wght@300;400;600&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0c14;color:#fff;font-family:'Barlow',sans-serif;overflow:hidden;width:100vw;height:100vh}
#C{position:fixed;top:0;left:0;width:100%;height:100%}
.controls{position:fixed;bottom:30px;left:50%;transform:translateX(-50%);z-index:10;display:flex;gap:4px;background:rgba(0,0,0,0.6);border-radius:8px;overflow:hidden;border:1px solid rgba(212,175,55,0.2);backdrop-filter:blur(12px)}
.btn{padding:14px 24px;border:none;background:transparent;color:rgba(255,255,255,0.5);font-family:'Barlow Condensed',sans-serif;font-size:14px;letter-spacing:2px;text-transform:uppercase;cursor:pointer;transition:all .3s}
.btn.on{color:#d4af37;background:rgba(212,175,55,0.15)}
.btn:hover{color:#fff}
.title{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:10;text-align:center;pointer-events:none}
.title h1{font-family:'Playfair Display',serif;font-size:28px;font-weight:900}
.title h1 span{color:#d4af37;font-style:italic}
.title p{font-family:'Barlow Condensed',sans-serif;font-size:12px;letter-spacing:4px;color:rgba(255,255,255,0.4);margin-top:4px}
</style>
</head>
<body>
<div id="C"></div>
<div class="title">
  <h1>PLEX FLEX<span>™</span></h1>
  <p>Telescopic Floor-Lift · 16 Rows · 2,600 Seats · Safety Interlocks</p>
</div>
<div class="controls">
  <button class="btn on" onclick="deploy('deployed')">Deploy Seating</button>
  <button class="btn" onclick="deploy('stowed')">Stow Below Floor</button>
  <button class="btn" onclick="toggleView()" style="border-left:1px solid rgba(212,175,55,0.3)">Swap Side View</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const FT = 0.3048;
const BW = 200*FT, BL = 250*FT, BH = 65*FT;
const BEAM_H = 4*FT;
const ROWS = 16;
const HORIZ_STEP = 4*FT;

// Telescopic vertical travel
const STOW_Y  = -24*FT;   // Below floor (stowed)
const DEPLOY_Y =  42*FT;   // Above floor (fully deployed)
const PIT_DEPTH = 26*FT;   // Pit depth below grade
const PIT_W = 12*FT;       // Pit width (N-S per end)
const BEAM_SPAN = 76*FT;   // Beam span (East-West across mat area)

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0e14);
const cam = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 500);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(50, 80, 50);
scene.add(sun);

// Materials
const matConcrete = new THREE.MeshStandardMaterial({color:0xd4cfc4});
const matSeat     = new THREE.MeshStandardMaterial({color:0x3a3a4a});
const matFloor    = new THREE.MeshStandardMaterial({color:0x8b1a1a});
const matPit      = new THREE.MeshStandardMaterial({color:0x2a2a2a});
const matFlap     = new THREE.MeshStandardMaterial({color:0x888880});
const matWall     = new THREE.MeshStandardMaterial({color:0x4a4a52, side:THREE.DoubleSide, transparent:true, opacity:0.25});

// Arena floor
const arenaFloor = new THREE.Mesh(new THREE.BoxGeometry(BW, 0.15, BL), matFloor);
arenaFloor.position.y = -0.075;
scene.add(arenaFloor);

// Building walls (transparent outline)
const wallGeo = new THREE.BoxGeometry(BW, BH, BL);
const wallEdges = new THREE.EdgesGeometry(wallGeo);
const wallLines = new THREE.LineSegments(wallEdges, new THREE.LineBasicMaterial({color:0x4a4a52, transparent:true, opacity:0.3}));
wallLines.position.y = BH/2;
scene.add(wallLines);

// North & South pits (visible cavities below the floor)
for(const side of [1, -1]) {
    const pitZ = side * (BL/2 - PIT_W/2);
    const pit = new THREE.Mesh(new THREE.BoxGeometry(BEAM_SPAN, PIT_DEPTH, PIT_W), matPit);
    pit.position.set(0, -PIT_DEPTH/2, pitZ);
    scene.add(pit);
}

// Beams array for animation
const beams = [];
const safetyFlaps = [];

function createTelescopicSection(zBase, stepDir) {
    for(let r = 0; r < ROWS; r++) {
        // Rake: each row is 4' higher than the previous
        const rowElevation = r * BEAM_H;
        // Horizontal stagger: top rows furthest from center, lower rows step forward
        const zOffset = (ROWS - 1 - r) * HORIZ_STEP * stepDir;
        const z = zBase - zOffset;

        const beamGeo = new THREE.BoxGeometry(BEAM_SPAN, BEAM_H * 0.9, BEAM_SPAN / ROWS);
        const seatGeo = new THREE.BoxGeometry(BEAM_SPAN * 0.95, 0.1, BEAM_SPAN / ROWS * 0.85);

        const beam = new THREE.Mesh(beamGeo, matConcrete);
        const seat = new THREE.Mesh(seatGeo, matSeat);

        // Stowed position: below floor
        const stowedY = STOW_Y + rowElevation;
        beam.position.set(0, stowedY, z);
        seat.position.set(0, stowedY + BEAM_H * 0.45, z);
        scene.add(beam);
        scene.add(seat);

        // Deployed Y: rises so row 0 is at floor level, row 15 is at top
        const deployedY = rowElevation + BEAM_H / 2;

        beams.push({
            row: r,
            mesh: beam,
            seatMesh: seat,
            stowedY: stowedY,
            deployedY: deployedY,
            z: z,
            startY: stowedY,
            targetY: stowedY
        });
    }

    // Safety flap for this end (covers the pit opening)
    const flapZ = zBase - ((ROWS - 1) * HORIZ_STEP * stepDir) / 2;
    const flap = new THREE.Mesh(
        new THREE.BoxGeometry(BEAM_SPAN, 0.1, PIT_W * 1.2),
        matFlap
    );
    flap.position.set(0, 0.05, zBase);
    scene.add(flap);
    safetyFlaps.push({ mesh: flap, openY: -PIT_DEPTH + 0.5, closedY: 0.05, startY: 0.05, targetY: 0.05 });
}

// North section: top row is furthest north (+Z)
createTelescopicSection(BL/2 - 20*FT, 1);
// South section: top row is furthest south (-Z)
createTelescopicSection(-BL/2 + 20*FT, -1);

function setTargets(mode) {
    beams.forEach(b => {
        if(mode === 'deployed') {
            b.targetY = b.deployedY;
        } else {
            b.targetY = b.stowedY;
        }
    });
    safetyFlaps.forEach(f => {
        // Flaps open (drop into pit) when deployed, close flush with floor when stowed
        f.targetY = (mode === 'deployed') ? f.openY : f.closedY;
    });
}

function animateBeams(mode) {
    beams.forEach(b => b.startY = b.mesh.position.y);
    safetyFlaps.forEach(f => f.startY = f.mesh.position.y);
    setTargets(mode);
    const startTime = performance.now();
    function update() {
        const t = Math.min((performance.now() - startTime) / 2500, 1);
        const eased = 1 - Math.pow(1 - t, 3);
        beams.forEach(b => {
            const y = b.startY + (b.targetY - b.startY) * eased;
            b.mesh.position.y = y;
            b.seatMesh.position.y = y + BEAM_H * 0.45;
        });
        safetyFlaps.forEach(f => {
            f.mesh.position.y = f.startY + (f.targetY - f.startY) * eased;
        });
        if(t < 1) requestAnimationFrame(update);
    }
    update();
}

function deploy(mode) {
    animateBeams(mode);
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('on'));
    event.target.classList.add('on');
}

// DUAL-VIEW CAMERA
let currentSide = 'front';
let tPos  = new THREE.Vector3(0, 35, BL/2 + 20);
let tLook = new THREE.Vector3(0, 10, 0);

function toggleView() {
    if(currentSide === 'front') {
        tPos.set(BW/2 + 20, 45, 0);
        currentSide = 'side';
    } else {
        tPos.set(0, 35, BL/2 + 20);
        currentSide = 'front';
    }
}

function render() {
    requestAnimationFrame(render);
    cam.position.lerp(tPos, 0.05);
    cam.lookAt(tLook);
    renderer.render(scene, cam);
}

// Start deployed
setTargets('deployed');
beams.forEach(b => {
    b.mesh.position.y = b.targetY;
    b.seatMesh.position.y = b.targetY + BEAM_H * 0.45;
});
safetyFlaps.forEach(f => { f.mesh.position.y = f.targetY; });
render();
</script>
</body>
</html>
