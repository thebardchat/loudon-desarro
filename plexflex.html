<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PLEX FLEX™ — Corrected Orientation & Dual-View</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=Barlow+Condensed:wght@300;400;600&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0c14;color:#fff;font-family:'Barlow',sans-serif;overflow:hidden;width:100vw;height:100vh}
#C{position:fixed;top:0;left:0;width:100%;height:100%}
.controls{position:fixed;bottom:30px;left:50%;transform:translateX(-50%);z-index:10;display:flex;gap:4px;background:rgba(0,0,0,0.6);border-radius:8px;overflow:hidden;border:1px solid rgba(212,175,55,0.2);backdrop-filter:blur(12px)}
.btn{padding:14px 24px;border:none;background:transparent;color:rgba(255,255,255,0.5);font-family:'Barlow Condensed',sans-serif;font-size:14px;letter-spacing:2px;text-transform:uppercase;cursor:pointer;transition:all .3s}
.btn.on{color:#d4af37;background:rgba(212,175,55,0.15)}
.btn:hover{color:#fff}
.title{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:10;text-align:center;pointer-events:none}
.title h1{font-family:'Playfair Display',serif;font-size:28px;font-weight:900}
.title h1 span{color:#d4af37;font-style:italic}
.title p{font-family:'Barlow Condensed',sans-serif;font-size:12px;letter-spacing:4px;color:rgba(255,255,255,0.4);margin-top:4px}
</style>
</head>
<body>
<div id="C"></div>
<div class="title">
  <h1>PLEX FLEX<span>™</span></h1>
  <p>North/South Swapped · Dual-Side Visibility · Stepped Rake Corrected</p>
</div>
<div class="controls">
  <button class="btn on" onclick="deploy('arena')">Inside Arena</button>
  <button class="btn" onclick="deploy('outdoor')">Outside Stadium</button>
  <button class="btn" onclick="deploy('stowed')">Stowed</button>
  <button class="btn" onclick="toggleView()" style="border-left:1px solid rgba(212,175,55,0.3)">Swap Side View</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const FT = 0.3048;
const BW = 200*FT, BL = 250*FT, BH = 65*FT;
const BEAM_L = 600*FT, BEAM_H = 4*FT;
const ROWS = 10;
const WALL_X = BW/2;
const HORIZ_OFFSET = 4*FT;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0e14);
const cam = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 500);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(50, 50, 50);
scene.add(sun);

// Materials
const matConcrete = new THREE.MeshStandardMaterial({color:0xd4cfc4});
const matSeat = new THREE.MeshStandardMaterial({color:0x3a3a4a});
const matFloor = new THREE.MeshStandardMaterial({color:0x8b1a1a});
const matWall = new THREE.MeshStandardMaterial({color:0x4a4a52, side:THREE.DoubleSide, transparent: true, opacity: 0.7});
const matGrass = new THREE.MeshStandardMaterial({color:0x3a6b2a});

// Environment
const arenaFloor = new THREE.Mesh(new THREE.PlaneGeometry(BW, BL), matFloor);
arenaFloor.rotation.x = -Math.PI/2;
scene.add(arenaFloor);

const grassField = new THREE.Mesh(new THREE.PlaneGeometry(BW, BL), matGrass);
grassField.rotation.x = -Math.PI/2;
grassField.position.x = BW;
scene.add(grassField);

const wall = new THREE.Mesh(new THREE.BoxGeometry(0.5, BH, BL), matWall);
wall.position.set(WALL_X, BH/2, 0);
scene.add(wall);

const beams = [];

function createSteppedSeating(zLimit, stepDirection) {
    for(let r = 0; r < ROWS; r++) {
        const y = r * BEAM_H + BEAM_H/2;
        // The top row (highest r) should be furthest back (North for North side, South for South side)
        // Each lower row steps FORWARD by 4'
        const zShift = (ROWS - 1 - r) * HORIZ_OFFSET * stepDirection;
        const z = zLimit - zShift;

        for(let s = 0; s < 5; s++) {
            const beam = new THREE.Mesh(new THREE.BoxGeometry(BEAM_L/5, BEAM_H*0.9, BEAM_L), matConcrete);
            const seat = new THREE.Mesh(new THREE.BoxGeometry(BEAM_L/6, 0.1, BEAM_L*0.9), matSeat);
            beam.rotation.y = Math.PI/2;
            seat.rotation.y = Math.PI/2;
            beam.position.set(0, y, z);
            seat.position.set(0, y + BEAM_H*0.45, z);
            scene.add(beam); scene.add(seat);
            beams.push({ row: r, mesh: beam, seatMesh: seat, startX: 0, targetX: 0 });
        }
    }
}

// Corrected North: Top row is most North (+Z). Step up as you go North.
createSteppedSeating(BL/2 - 20*FT, 1);
// Corrected South: Top row is most South (-Z). Step up as you go South.
createSteppedSeating(-BL/2 + 20*FT, -1);

function setBeamTargets(mode){
  beams.forEach(b => {
    if(mode === 'arena') b.targetX = WALL_X - (BEAM_L/2);
    else if(mode === 'outdoor') b.targetX = WALL_X + (BEAM_L/2);
    else b.targetX = WALL_X;
  });
}

function animatePlexFlex(mode){
  beams.forEach(b => b.startX = b.mesh.position.x);
  setBeamTargets(mode);
  const startTime = performance.now();
  function update(){
    const t = Math.min((performance.now() - startTime) / 1500, 1);
    const eased = 1 - Math.pow(1 - t, 3);
    beams.forEach(b => {
      const x = b.startX + (b.targetX - b.startX) * eased;
      b.mesh.position.x = x; b.seatMesh.position.x = x;
    });
    if(t < 1) requestAnimationFrame(update);
  }
  update();
}

function deploy(mode){
  animatePlexFlex(mode);
  document.querySelectorAll('.btn').forEach(b => b.classList.remove('on'));
  event.target.classList.add('on');
}

// DUAL-VIEW CAMERA LOGIC
let currentSide = 'inside';
let tPos = new THREE.Vector3(WALL_X - 60, 45, 60);
let tLook = new THREE.Vector3(WALL_X, 15, 0);

function toggleView() {
    if(currentSide === 'inside') {
        tPos.set(WALL_X + 60, 45, -60);
        currentSide = 'outside';
    } else {
        tPos.set(WALL_X - 60, 45, 60);
        currentSide = 'inside';
    }
}

function render(){
  requestAnimationFrame(render);
  cam.position.lerp(tPos, 0.05);
  cam.lookAt(tLook);
  renderer.render(scene, cam);
}
setBeamTargets('arena');
beams.forEach(b => { b.mesh.position.x = b.targetX; b.seatMesh.position.x = b.targetX; });
render();
</script>
</body>
</html>
